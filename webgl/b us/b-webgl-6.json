{"history":[{"local":{"id":"82400f4f-02c7-43a3-98bf-7393e2ab4911","canvas":{},"ctx":{}},"visible":true,"locked":false,"aspectRatio":1,"layerName":"","isElement":true,"opacity":1,"displace":0,"trackMouse":0,"mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"layerType":"image","imageLoaded":false,"effects":[],"size":0.264,"rotation":0,"height":1615,"repeat":0,"fitToCanvas":false,"scaleX":1,"scaleY":1,"src":"https://assets.unicorn.studio/images/zLe0XBklTKV9oVYsb55UdaqiTXg2/B US.png","speed":0.5,"thumb":"https://assets.unicorn.studio/images/zLe0XBklTKV9oVYsb55UdaqiTXg2/B US_@thumbnail.png?authuser=0","translateX":58,"translateY":-2,"width":1201,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color/(color.a + 0.00000001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"local":{"id":"1cbf8b26-e3b5-48f1-811e-450e1430a32f","canvas":{},"ctx":{}},"visible":true,"locked":false,"aspectRatio":1.372993389990557,"layerName":"","isElement":true,"opacity":1,"displace":0,"trackMouse":0,"mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"layerType":"shape","borderRadius":0,"coords":[[14,0],[14,0],[14,429],[14,429]],"effects":[],"fill":["#777777"],"gradientAngle":0,"gradientType":"linear","rotation":0,"translateX":311,"translateY":19,"type":"rectangle","numSides":3,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color/(color.a + 0.00000001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"blinds","speed":0.04,"trackMouse":0.02,"mouseMomentum":1,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { switch(24) { case 0: return t; break; case 1: return t * t; break; case 2: return t * (2.0 - t); break; case 3: return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; break; case 4: return t * t * t; break; case 5: return --t * t * t + 1.0; break; case 6: return t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0; break; case 7: return t * t * t * t; break; case 8: return 1.0 - (--t) * t * t * t; break; case 9: return t < 0.5 ? 8.0 * t * t * t * t : 1.0 - 8.0 * (--t) * t * t * t; break; case 10: return t * t * t * t * t; break; case 11: return 1.0 + (--t) * t * t * t * t; break; case 12: return t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 + 16.0 * (--t) * t * t * t * t; break; case 13: return 1.0 - sqrt(1.0 - t * t); break; case 14: return sqrt((2.0 - t) * t); break; case 15: return t < 0.5 ? (1.0 - sqrt(1.0 - 4.0 * t * t)) / 2.0 : (sqrt(-((2.0 * t) - 3.0) * ((2.0 * t) - 1.0)) + 1.0) / 2.0; break; case 16: return t == 0.0 ? 0.0 : pow(2.0, 10.0 * (t - 1.0)); break; case 17: return t == 1.0 ? 1.0 : 1.0 - pow(2.0, -10.0 * t); break; case 18: return t == 0.0 ? 0.0 : t == 1.0 ? 1.0 : t < 0.5 ? pow(2.0, (20.0 * t) - 10.0) / 2.0 : (2.0 - pow(2.0, -20.0 * t + 10.0)) / 2.0; break; case 19: return 1.0 - cos((t * 3.141592654) / 2.0); break; case 20: return sin((t * 3.141592654) / 2.0); break; case 21: return -(cos(3.141592654 * t) - 1.0) / 2.0; break; case 22: return t == 0.0 ? 0.0 : t == 1.0 ? 1.0 : -pow(2.0, 10.0 * t - 10.0) * sin((t * 10.0 - 10.75) * ((2.0 * 3.141592654) / 3.0)); break; case 23: return t == 0.0 ? 0.0 : t == 1.0 ? 1.0 : pow(2.0, -10.0 * t) * sin((t * 10.0 - 0.75) * ((2.0 * 3.141592654) / 3.0)) + 1.0; break; case 24: return t == 0.0 ? 0.0 : t == 1.0 ? 1.0 : t < 0.5 ? -(pow(2.0, 20.0 * t - 10.0) * sin((20.0 * t - 11.125) * ((2.0 * 3.141592654) / 4.5))) / 2.0 : (pow(2.0, -20.0 * t + 10.0) * sin((20.0 * t - 11.125) * ((2.0 * 3.141592654) / 4.5))) / 2.0 + 1.0; break; } }const float STEPS = 10.0; const float PI = 3.14159265359;mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec3 chromatic_abberation(vec2 st, vec2 aberrated) { vec4 red = vec4(0); vec4 blue = vec4(0); vec4 green = vec4(0);float invSteps = 1.0 / STEPS; float invStepsHalf = invSteps * 0.5;for(float i = 1.0; i <= STEPS; i++) { vec2 offset = aberrated * (i * invSteps); red += texture(uTexture, st - offset) * invSteps; blue += texture(uTexture, st + offset) * invSteps; green += texture(uTexture, st - offset * 0.5) * invStepsHalf; green += texture(uTexture, st + offset * 0.5) * invStepsHalf; }return vec3(red.r, green.g, blue.b); }vec2 scaleAspect(vec2 st, float aspectRatio) { return st * vec2(aspectRatio, 1.0); }vec2 unscaleAspect(vec2 st) { float aspectRatio = uResolution.x / uResolution.y; return st * vec2(1.0/aspectRatio, 1.0); }vec2 rotate(vec2 st, float angle) { float s = sin(angle); float c = cos(angle); mat2 rot = mat2(c, -s, s, c); return rot * st; }struct StructFunc { vec2 st; vec3 distort; };StructFunc style0(vec2 st, vec2 pos, float divisions, float dist, float amount, vec3 first, vec3 second, vec3 third) { float segment = fract((st.y + 1. - pos.y - 1. + uTime * 0.01) * divisions); vec3 distort = mix(mix(first, second, segment * 2.), mix(second, third, (segment - 0.5) / (1. - 0.5)), step(0.5, segment)); st.y -= pow(distort.r, dist) / 10. * amount; st.y += pow(distort.b, dist) / 10. * amount;st = rot(0.00 * 2. * PI) * (st - pos) + pos; st = unscaleAspect(st);return StructFunc(st, distort); }StructFunc getStyle(vec2 st, vec2 pos, float divisions, float dist, float amount, vec3 first, vec3 second, vec3 third) { return style0(st, pos, divisions, dist, amount, first, second, third); }vec4 blinds(vec2 st, float mDist) { float aspectRatio = uResolution.x / uResolution.y; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos - 0.5), 0.02) * floor(1.00); pos = scaleAspect(pos, aspectRatio); st = scaleAspect(st, aspectRatio);st = rotate(st - pos, -0.00 * 2.0 * PI) + pos;vec3 first = vec3(1, 0, 0); vec3 second = vec3(0, 1, 0); vec3 third = vec3(0, 0, 1); float divisions = 2. + 0.00 * 30.; float dist = 1.00 * 4. + 1.; float amount = 0.05 * mDist;StructFunc result = getStyle(st, pos, divisions, dist, amount, first, second, third); vec4 color = texture(uTexture, result.st);vec2 offset = vec2(pow(result.distort.r, dist), pow(result.distort.b, dist)) * vec2(0.1) * amount * 1.00; color.rgb = chromatic_abberation(result.st, offset * 1.00);return color; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x / uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos - 0.5), 0.02); vec2 pos = mPos; float mDist = ease(24, max(0., 1. - distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00)));vec4 col = blinds(uv, mDist); fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"texturize","speed":0.1,"animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;float random (in float x) { return fract(sin(x)*43758.5453); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float time = floor(uTime * 0.5) * 2.; float size = 0.85 * 0.2 * random(time + 0.001); float floorY = floor(uv.y/size); float floorX = floor(uv.x/size); float phase = 0.00 * 0.01; float phaseTime = phase + uTime; float chromab = 0.50 * 0.75; float offset = 0.;float stableRandom = random(sin(floorY + offset + phase)); float threshold = 0.5 + (1. - 0.04 * 2.) / 2.; float glitchMod = smoothstep(threshold - 0.01, threshold + 0.01, stableRandom);glitchMod += 0.001; float stabilizedOffset = smoothstep(0.0, 1.0, stableRandom); float offX = (stabilizedOffset * 0.08 - 0.08 / 2.0) / 5.0; offX = clamp(offX, -0.08 / 10.0, 0.08 / 10.0);uv.x = mix(uv.x, uv.x + offX * 2., glitchMod);float waveFreq = 30.0; float waveAmp = 0.005 * 0.00;float rogue = smoothstep(0., 2., sin((uv.y + 0.00) * waveFreq * (1. - 0.85) * 2. + uTime * 0.05) - 0.5) * 0.2 * 0.00; uv.x += sin(uv.y * waveFreq + uTime) * waveAmp + rogue; uv.y += sin(uv.x * waveFreq + uTime) * waveAmp; float waveX = sin(uv.y * waveFreq + uTime) * waveAmp + rogue * chromab * 0.2;uv = clamp(uv, vec2(0.0), vec2(1.0));vec4 color = texture(uTexture, uv); color.r = texture(uTexture, vec2(clamp(uv.x + (glitchMod * -offX * chromab - waveX), 0.0, 1.0), uv.y)).r; color.b = texture(uTexture, vec2(clamp(uv.x + (glitchMod * offX * chromab + waveX), 0.0, 1.0), uv.y)).b; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}}],"options":{"name":"B for Us","fps":60,"dpi":2,"scale":1,"includeLogo":true,"isProduction":false,"version":"1.2.8"},"version":"1.2.8"}
