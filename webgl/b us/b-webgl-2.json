{"history":[{"visible":true,"aspectRatio":1,"layerType":"effect","type":"gradient","speed":0.25,"trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;const vec3 uColors[1] = vec3[]( vec3(0.945098, 0.945098, 0.945098) );uniform vec2 uMousePos; uniform vec2 uResolution;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) { return uColors[0]; }void main() { vec2 uv = vTextureCoord; vec2 res = uResolution; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); uv -= pos; uv /= (0.50*2.); uv = rotate(uv, (0.00 - 0.5) * 2. * 3.14159265); vec4 color = vec4(getColor(uv), 1); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false}},{"local":{"id":"e538d619-8fff-4211-ac96-5aafb03351d5","canvas":{},"ctx":{}},"visible":true,"locked":false,"aspectRatio":1,"layerName":"","isElement":true,"opacity":1,"displace":0,"trackMouse":0,"mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"layerType":"image","imageLoaded":false,"effects":[],"size":0.46900000000000003,"rotation":0,"height":1615,"repeat":0,"fitToCanvas":false,"scaleX":1,"scaleY":1,"src":"https://assets.unicorn.studio/images/Zekmn04Vm3ZgT5JYDFs6d6ArtvR2/B US.png","speed":0.5,"thumb":"https://assets.unicorn.studio/images/Zekmn04Vm3ZgT5JYDFs6d6ArtvR2/B US_@thumbnail.png?authuser=0","translateX":-156,"translateY":-0.5,"width":1201,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color/(color.a + 0.00000001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"texturize","phase":0.61,"speed":0.01,"animating":true,"mouseMomentum":0,"isMask":0,"states":{"appear":[{"type":"appear","id":"3c6564a5-49f5-4f5c-83d7-eba885456c57","prop":"phase","value":0.55,"transition":{"ease":"easeInOutQuart","duration":100000,"delay":0},"complete":false,"progress":0,"initialStateSet":false,"uniformData":{"type":"1f","name":"uPhase"}}],"scroll":[]},"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform float uPhase;float random (in float x) { return fract(sin(x)*43758.5453); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float time = floor(uTime * 0.5) * 2.; float size = 0.76 * 0.2 * random(time + 0.001); float floorY = floor(uv.y/size); float floorX = floor(uv.x/size); float phase = uPhase * 0.01; float phaseTime = phase + uTime; float chromab = 0.01 * 0.75; float offset = 0.;float stableRandom = random(sin(floorY + offset + phase)); float threshold = 0.5 + (1. - 0.10 * 2.) / 2.; float glitchMod = smoothstep(threshold - 0.01, threshold + 0.01, stableRandom);glitchMod += 0.001; float stabilizedOffset = smoothstep(0.0, 1.0, stableRandom); float offX = (stabilizedOffset * 0.20 - 0.20 / 2.0) / 5.0; offX = clamp(offX, -0.20 / 10.0, 0.20 / 10.0);uv.x = mix(uv.x, uv.x + offX * 2., glitchMod);float waveFreq = 30.0; float waveAmp = 0.005 * 0.00;float rogue = smoothstep(0., 2., sin((uv.y + uPhase) * waveFreq * (1. - 0.76) * 2. + uTime * 0.05) - 0.5) * 0.2 * 0.00; uv.x += sin(uv.y * waveFreq + uTime) * waveAmp + rogue; uv.y += sin(uv.x * waveFreq + uTime) * waveAmp; float waveX = sin(uv.y * waveFreq + uTime) * waveAmp + rogue * chromab * 0.2;uv = clamp(uv, vec2(0.0), vec2(1.0));vec4 color = texture(uTexture, uv); color.r = texture(uTexture, vec2(clamp(uv.x + (glitchMod * -offX * chromab - waveX), 0.0, 1.0), uv.y)).r; color.b = texture(uTexture, vec2(clamp(uv.x + (glitchMod * offX * chromab + waveX), 0.0, 1.0), uv.y)).b; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}}],"options":{"name":"B_US_Page","fps":60,"dpi":2,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.2.8"}
